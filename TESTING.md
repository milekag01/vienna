# Vienna CLI — Stage 1 Testing Guide

## Prerequisites

You need these installed before testing:

- **Docker Desktop** — running (check: `docker info`)
- **jq** — `brew install jq`
- **atlas** — for Go service migrations ([install](https://atlasgo.io/getting-started#installation))
- **Node.js / npm** — for Prisma migrations
- Base `.env` files in your main repo checkouts (these get copied and overridden per-instance):
  - `commenda-logical-backend/.env`
  - `sales-tax-api-2/.env`

## Commands

| Command | What it does |
|---|---|
| `vienna spawn <name> --branch <branch>` | Create a fully isolated environment |
| `vienna stop <name>` | Pause Docker containers (data preserved) |
| `vienna start <name>` | Resume stopped containers |
| `vienna destroy <name>` | Tear everything down permanently |
| `vienna list` | Show all instances with status and ports |
| `vienna help` | Print usage info |

## Quick Smoke Test (2 minutes)

```bash
cd ~/Desktop/Vienna

# 1. Check clean state
bash vienna/bin/vienna.sh list
# Expected: "No instances found."

# 2. Spawn an instance
bash vienna/bin/vienna.sh spawn smoke --branch main
# Expected: ports allocated → worktrees created → Docker starts → .env generated → migrations attempted → summary printed

# 3. Verify it's listed
bash vienna/bin/vienna.sh list
# Expected: table row showing "smoke", branch "main", status "running", port numbers

# 4. Stop it
bash vienna/bin/vienna.sh stop smoke
# Expected: containers stop, "Data is preserved" message

# 5. Verify stopped status
bash vienna/bin/vienna.sh list
# Expected: status shows "stopped" (yellow)

# 6. Start it back up
bash vienna/bin/vienna.sh start smoke
# Expected: containers resume, port summary printed

# 7. Verify running again
bash vienna/bin/vienna.sh list
# Expected: status shows "running" (green)

# 8. Destroy it
bash vienna/bin/vienna.sh destroy smoke
# Expected: Docker removed, worktrees removed, ports freed

# 9. Confirm clean
bash vienna/bin/vienna.sh list
# Expected: "No instances found."
```

## Full Test Scenarios

### Test 1: Spawn and inspect

```bash
bash vienna/bin/vienna.sh spawn my-test --branch main
```

**What happens step by step:**
1. Port offset allocated (reuses freed offsets, otherwise increments)
2. Git worktrees created in `instances/my-test/` for all 3 repos (commenda, commenda-logical-backend, sales-tax-api-2)
3. Docker containers start: 2x Postgres, 1x Redis, 1x LocalStack
4. `.env` files generated by copying your base `.env` and overriding infra vars
5. Migrations attempted (non-fatal if they fail)
6. Summary printed with all ports

**Verify manually:**
```bash
# Worktrees exist
ls instances/my-test/
# Expected: commenda/  commenda-logical-backend/  sales-tax-api-2/

# Each is on the right branch
git -C instances/my-test/commenda branch --show-current
# Expected: main

# Docker containers running
docker ps --filter "name=vienna-my-test" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
# Expected: 4 containers, all healthy

# .env files generated with instance-specific ports
grep DATABASE_URL instances/my-test/commenda-logical-backend/.env
# Expected: postgres://commenda:commenda@localhost:5501/commenda (port = 5500 + offset)

grep DATABASE_URL instances/my-test/sales-tax-api-2/.env
# Expected: postgres://salestax:salestax@localhost:5601/salestax?sslmode=disable

# LocalStack queues created
AWS_ACCESS_KEY_ID=test AWS_SECRET_ACCESS_KEY=test aws \
  --endpoint-url=http://localhost:4567 sqs list-queues
# Expected: 22 queue URLs (21 standard + 1 FIFO)
# Note: LocalStack port = 4566 + offset. If offset=1, port=4567.

# S3 buckets created
AWS_ACCESS_KEY_ID=test AWS_SECRET_ACCESS_KEY=test aws \
  --endpoint-url=http://localhost:4567 s3 ls
# Expected: commenda-dev, commenda-auto-delete-dev, sales-tax-bucket-dev
```

### Test 2: Stop and start (data persists)

```bash
# Connect to Postgres, create some data
psql "postgres://commenda:commenda@localhost:5501/commenda" -c "CREATE TABLE test_persist (id int);"
psql "postgres://commenda:commenda@localhost:5501/commenda" -c "INSERT INTO test_persist VALUES (42);"

# Stop
bash vienna/bin/vienna.sh stop my-test

# Verify containers are stopped
docker ps --filter "name=vienna-my-test"
# Expected: nothing (stopped containers don't show without -a)

# Start
bash vienna/bin/vienna.sh start my-test

# Data still there
psql "postgres://commenda:commenda@localhost:5501/commenda" -c "SELECT * FROM test_persist;"
# Expected: 42
```

### Test 3: Multiple simultaneous instances

```bash
bash vienna/bin/vienna.sh spawn env-a --branch main
bash vienna/bin/vienna.sh spawn env-b --branch main
# NOTE: This will FAIL because two worktrees can't share the same branch.
# Expected error: git will refuse to create a second worktree on 'main'.
# This is a known limitation — each instance needs a different branch (or the same branch via a detached HEAD, which we don't support yet).

# Instead, test with different branches:
bash vienna/bin/vienna.sh spawn env-a --branch main
bash vienna/bin/vienna.sh spawn env-b --branch <some-other-branch>
# Expected: both listed in `vienna list` with different port offsets, no port conflicts

bash vienna/bin/vienna.sh list
# Expected: two rows, different ports, both "running"

bash vienna/bin/vienna.sh destroy env-a
bash vienna/bin/vienna.sh destroy env-b
```

### Test 4: Destroy is idempotent-ish

```bash
bash vienna/bin/vienna.sh spawn cleanup-test --branch main
bash vienna/bin/vienna.sh destroy cleanup-test

# Try again
bash vienna/bin/vienna.sh destroy cleanup-test
# Expected: "Instance 'cleanup-test' not found"

# Registry is clean
bash vienna/bin/vienna.sh list
# Expected: "No instances found."
```

### Test 5: Error handling

```bash
# Missing branch flag
bash vienna/bin/vienna.sh spawn no-branch
# Expected: "--branch is required"

# Missing name
bash vienna/bin/vienna.sh spawn
# Expected: "Instance name is required"

# Bad name
bash vienna/bin/vienna.sh spawn "my instance!" --branch main
# Expected: "Instance name must be alphanumeric"

# Duplicate name
bash vienna/bin/vienna.sh spawn dup --branch main
bash vienna/bin/vienna.sh spawn dup --branch main
# Expected: "Instance 'dup' already exists"

# Stop/start nonexistent
bash vienna/bin/vienna.sh stop ghost
# Expected: "Instance 'ghost' not found"

# Unknown command
bash vienna/bin/vienna.sh foobar
# Expected: "Unknown command: foobar"
```

## Port Allocation Scheme

Each instance gets an offset N (starting at 1, reuses freed offsets):

| Service | Port formula | Offset 1 | Offset 2 |
|---|---|---|---|
| PostgreSQL (NestJS) | 5500 + N | 5501 | 5502 |
| PostgreSQL (Go) | 5600 + N | 5601 | 5602 |
| Redis | 6400 + N | 6401 | 6402 |
| LocalStack | 4566 + N | 4567 | 4568 |
| NestJS backend | 8100 + N | 8101 | 8102 |
| Go API | 8200 + N | 8201 | 8202 |

NestJS/Go API ports are written to `.env` but you still start those services yourself — Vienna only manages the infrastructure containers.

## File Locations

| Path | Purpose |
|---|---|
| `vienna/bin/vienna.sh` | CLI entry point |
| `vienna/lib/*.sh` | Library modules |
| `vienna/docker/` | Docker Compose + LocalStack init |
| `.vienna-state/registry.json` | Port offset registry |
| `.vienna-state/instances/<name>/config.json` | Per-instance config |
| `instances/<name>/` | Git worktrees + generated .env files |

---

## Stage 2: Ticket-Driven Agent Spawning

### Setup

1. **Get your Linear API key:**
   - Go to https://linear.app/settings/api (or: Linear → Settings → API)
   - Click "Create key", label it "Vienna"
   - Copy the key (shown only once)

2. **Save it in Vienna's secrets file:**
   ```bash
   mkdir -p .vienna-state
   echo 'VIENNA_LINEAR_API_KEY=lin_api_YOUR_KEY_HERE' >> .vienna-state/secrets.env
   ```

### Commands

| Command | What it does |
|---|---|
| `vienna spawn --ticket COM-4521` | Fetch ticket, create branch, spawn environment, inject task context, open Cursor |
| `vienna spawn --ticket https://linear.app/.../COM-4521/...` | Same, but from a Linear URL |
| `vienna spawn --ticket COM-4521 --branch custom-branch` | Ticket mode with explicit branch override |

### Quick Test: Ticket Spawn

```bash
cd ~/Desktop/Vienna

# 1. Spawn from a ticket
bash vienna/bin/vienna.sh spawn --ticket COM-4521
# Expected:
#   - Fetches ticket from Linear (title, description, priority, labels)
#   - Auto-derives instance name: "com-4521"
#   - Auto-derives branch from Linear's suggested branch (or generates one)
#   - Creates branch if it doesn't exist
#   - Full spawn flow: worktrees, Docker, .env, migrations
#   - Writes .cursor/rules/task.mdc with ticket context
#   - Writes .vienna-task.json with machine-readable context
#   - Opens Cursor window at instance directory

# 2. Verify task context was written
cat instances/com-4521/.cursor/rules/task.mdc
# Expected: Ticket title, description, acceptance criteria, port info

cat instances/com-4521/.vienna-task.json
# Expected: JSON with ticket, title, description, ports, etc.

# 3. Check it's listed
bash vienna/bin/vienna.sh list

# 4. Clean up
bash vienna/bin/vienna.sh destroy com-4521
```

### How It Works

When you run `vienna spawn --ticket COM-4521`:

1. **Parse input** — Accepts ticket ID (`COM-4521`) or full Linear URL
2. **Fetch from Linear** — GraphQL API call to get title, description, priority, labels, suggested branch name, assignee, comments
3. **Derive name + branch** — Instance name: `com-4521`. Branch: Linear's suggested branch, or `com-4521-<slugified-title>`
4. **Create branch if needed** — If the branch doesn't exist in any repo, creates it from `origin/main`
5. **Normal spawn flow** — Worktrees, Docker, .env, deps, migrations (exactly like a regular spawn)
6. **Write task context** — `.cursor/rules/task.mdc` (Cursor reads automatically) + `.vienna-task.json`
7. **Open Cursor** — `cursor instances/com-4521/` opens a new Cursor window. The agent loads `task.mdc` and knows what to work on

### What the Agent Sees

The `.cursor/rules/task.mdc` file is auto-loaded by Cursor (it has `alwaysApply: true`). The agent gets:

- Ticket title and link
- Full description
- Priority, status, labels, assignee
- All instance ports (so it knows where to test)
- Working directory and branch info
- Guidelines for committing

### Secrets File

The file `.vienna-state/secrets.env` is gitignored and stores sensitive values:

```bash
# .vienna-state/secrets.env
VIENNA_LINEAR_API_KEY=lin_api_xxxxxxxxxxxxxxxxxxxxx
```

This is loaded automatically by the CLI at startup.

---

## Known Limitations

1. **Two instances can't use the same branch** — git worktree restriction. You'll get git's error message.
2. **First spawn takes a while** — `npm install` for Prisma on a fresh worktree can be slow. Migration failures are non-fatal; spawn still succeeds.
3. **LocalStack queues reset on destroy** — the `stop`/`start` cycle preserves them, but `destroy` wipes volumes.
4. **No `vienna migrate` command yet** — if migrations fail during spawn, run them manually:
   ```bash
   cd instances/<name>/commenda-logical-backend
   DATABASE_URL="postgres://commenda:commenda@localhost:<port>/commenda" npx prisma migrate deploy

   cd instances/<name>/sales-tax-api-2
   atlas migrate apply --dir file://database/migrations --url "postgres://salestax:salestax@localhost:<port>/salestax?sslmode=disable"
   ```
5. **Services aren't auto-started** — Vienna sets up infrastructure (DBs, Redis, AWS) and generates config. You start NestJS/Go yourself from the worktree directories.
6. **Linear API key required for --ticket** — Without it, you'll get an error with setup instructions.
